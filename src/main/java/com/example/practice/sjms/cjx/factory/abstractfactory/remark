抽象工厂模式


成员角色

　　抽象工厂（AbstractFactory）：客户端直接引用，由未实现的工厂方法组成，子类必须实现其工厂方法创建产品家族。

　　具体工厂（ConcreteFactory）：实现抽象工厂接口，负责实现工厂方法，一个具体工厂可以创建一组产品。

　　抽象产品（AbstractProduct）：产品家族的父类，由此可以衍生很多子产品。

　　具体产品（Product）：衍生自抽象产品，由工厂方法直接创建。


模式的应用场景
当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。


抽象工厂模式的扩展有一定的“开闭原则”倾斜性：

当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。
另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。



工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类，在这里我们就可以实现“开发-封闭”原则，无论加多少产品类，
我们都不用修改原来类中的代码，而是通过增加工厂类来实现。但是这还是有缺点的，如果产品类过多，我们就要生成很多的工厂类。假如我们要实现的产品接口不止一个，
也就是有多个产品接口，不同产品接口有对应的产品族。什么是产品族呢？简单的理解就是，不同牌子产的车里面会有跑车类型，家庭类型，商用类型等的车，
不同牌子的车的跑车类型的车可以组成一个产品族。对于这种情况我们可以采用抽象工厂模式。

我们现在是把飞机和汽车当成了一个簇，比如这时候我们又新增了别的牌子的



